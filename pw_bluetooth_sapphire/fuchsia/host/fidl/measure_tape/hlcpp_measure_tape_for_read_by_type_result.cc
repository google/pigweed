// Copyright 2024 The Pigweed Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// Code generated by "measure-tape"; DO NOT EDIT.
//
// See tools/fidl/measure-tape/README.md

// clang-format off
#include "hlcpp_measure_tape_for_read_by_type_result.h"

#include <fuchsia/bluetooth/gatt2/cpp/fidl.h>
#include <zircon/types.h>


namespace measure_tape {
namespace fuchsia {
namespace bluetooth {
namespace gatt2 {

namespace {

class MeasuringTape {
 public:
  MeasuringTape() = default;

  void Measure(const ::fuchsia::bluetooth::gatt2::Handle& value) {
    num_bytes_ += FIDL_ALIGN(8);
  }

  void Measure(const ::fuchsia::bluetooth::gatt2::ReadByTypeResult& value) {
    num_bytes_ += 16;
    MeasureOutOfLine(value);
  }

  void MeasureOutOfLine(const ::fuchsia::bluetooth::gatt2::ReadByTypeResult& value) {
    int32_t max_ordinal = 0;
    if (value.has_handle()) {
      Measure(value.handle());
      max_ordinal = 1;
    }
    if (value.has_value()) {
      Measure(value.value());
      max_ordinal = 2;
    }
    if (value.has_error()) {
      max_ordinal = 3;
    }
    num_bytes_ += 8 * max_ordinal;
  }

  void Measure(const ::fuchsia::bluetooth::gatt2::ReadValue& value) {
    num_bytes_ += 16;
    MeasureOutOfLine(value);
  }

  void MeasureOutOfLine(const ::fuchsia::bluetooth::gatt2::ReadValue& value) {
    int32_t max_ordinal = 0;
    if (value.has_handle()) {
      Measure(value.handle());
      max_ordinal = 1;
    }
    if (value.has_value()) {
      num_bytes_ += 16;
      num_bytes_ += FIDL_ALIGN(value.value().size() * 1);
      max_ordinal = 2;
    }
    if (value.has_maybe_truncated()) {
      max_ordinal = 3;
    }
    num_bytes_ += 8 * max_ordinal;
  }

  Size Done() {
    if (maxed_out_) {
      return Size(ZX_CHANNEL_MAX_MSG_BYTES, ZX_CHANNEL_MAX_MSG_HANDLES);
    }
    return Size(num_bytes_, num_handles_);
  }

private:
  void MaxOut() { maxed_out_ = true; }

  bool maxed_out_ = false;
  int64_t num_bytes_ = 0;
  int64_t num_handles_ = 0;
};

}  // namespace


Size Measure(const ::fuchsia::bluetooth::gatt2::ReadByTypeResult& value) {
  MeasuringTape tape;
  tape.Measure(value);
  return tape.Done();
}



}  // gatt2
}  // bluetooth
}  // fuchsia
}  // measure_tape

